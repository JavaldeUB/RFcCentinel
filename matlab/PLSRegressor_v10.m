%% PLSRegressor_v8.m
% Script for PLS regression of the randomized database for Eth+H2O in 
% different concentrations:
% 1) the database is located in:
%    filename: C:\Users\javit\Documents\curso24_25\Docencia\EHU\EMIMEP\SSS\Lab\matlab\organized_data_with_baseline.csv
% 2) the order files are  in:
%    filename: C:\Users\javit\Documents\curso24_25\Docencia\EHU\EMIMEP\SSS\Lab\python\dataBase_EthH2O_1p2mL_1p6to3GHz_random\randomList.txt
% 3) 
% Auto-generated by MATLAB on 29-Dec-2024 07:09:54

%% Set up the plotting 
clear all
plt = input("Do you wish to plot the results (0->No|1->Yes): ");

%% Set up the Import Options and import the data
opts = delimitedTextImportOptions("NumVariables", 205);

% Specify range and delimiter
opts.DataLines = [2, Inf];
opts.Delimiter = ",";

% Specify column names and types
opts.VariableNames = ["Freq_1", "Freq_2", "Freq_3", "Freq_4", "Freq_5", "Freq_6", "Freq_7", "Freq_8", "Freq_9", "Freq_10", "Freq_11", "Freq_12", "Freq_13", "Freq_14", "Freq_15", "Freq_16", "Freq_17", "Freq_18", "Freq_19", "Freq_20", "Freq_21", "Freq_22", "Freq_23", "Freq_24", "Freq_25", "Freq_26", "Freq_27", "Freq_28", "Freq_29", "Freq_30", "Freq_31", "Freq_32", "Freq_33", "Freq_34", "Freq_35", "Freq_36", "Freq_37", "Freq_38", "Freq_39", "Freq_40", "Freq_41", "Freq_42", "Freq_43", "Freq_44", "Freq_45", "Freq_46", "Freq_47", "Freq_48", "Freq_49", "Freq_50", "Freq_51", "Freq_52", "Freq_53", "Freq_54", "Freq_55", "Freq_56", "Freq_57", "Freq_58", "Freq_59", "Freq_60", "Freq_61", "Freq_62", "Freq_63", "Freq_64", "Freq_65", "Freq_66", "Freq_67", "Freq_68", "Freq_69", "Freq_70", "Freq_71", "Freq_72", "Freq_73", "Freq_74", "Freq_75", "Freq_76", "Freq_77", "Freq_78", "Freq_79", "Freq_80", "Freq_81", "Freq_82", "Freq_83", "Freq_84", "Freq_85", "Freq_86", "Freq_87", "Freq_88", "Freq_89", "Freq_90", "Freq_91", "Freq_92", "Freq_93", "Freq_94", "Freq_95", "Freq_96", "Freq_97", "Freq_98", "Freq_99", "Freq_100", "Freq_101", "Freq_102", "Freq_103", "Freq_104", "Freq_105", "Freq_106", "Freq_107", "Freq_108", "Freq_109", "Freq_110", "Freq_111", "Freq_112", "Freq_113", "Freq_114", "Freq_115", "Freq_116", "Freq_117", "Freq_118", "Freq_119", "Freq_120", "Freq_121", "Freq_122", "Freq_123", "Freq_124", "Freq_125", "Freq_126", "Freq_127", "Freq_128", "Freq_129", "Freq_130", "Freq_131", "Freq_132", "Freq_133", "Freq_134", "Freq_135", "Freq_136", "Freq_137", "Freq_138", "Freq_139", "Freq_140", "Freq_141", "Freq_142", "Freq_143", "Freq_144", "Freq_145", "Freq_146", "Freq_147", "Freq_148", "Freq_149", "Freq_150", "Freq_151", "Freq_152", "Freq_153", "Freq_154", "Freq_155", "Freq_156", "Freq_157", "Freq_158", "Freq_159", "Freq_160", "Freq_161", "Freq_162", "Freq_163", "Freq_164", "Freq_165", "Freq_166", "Freq_167", "Freq_168", "Freq_169", "Freq_170", "Freq_171", "Freq_172", "Freq_173", "Freq_174", "Freq_175", "Freq_176", "Freq_177", "Freq_178", "Freq_179", "Freq_180", "Freq_181", "Freq_182", "Freq_183", "Freq_184", "Freq_185", "Freq_186", "Freq_187", "Freq_188", "Freq_189", "Freq_190", "Freq_191", "Freq_192", "Freq_193", "Freq_194", "Freq_195", "Freq_196", "Freq_197", "Freq_198", "Freq_199", "Freq_200", "Freq_201", "Concentration", "Vial", "Day", "Time"];
opts.VariableTypes = ["double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"];

% Specify file level properties
opts.ExtraColumnsRule = "ignore";
opts.EmptyLineRule = "read";

% Import the data
%organizeddatawithbaseline = readtable("C:\Users\jalon\Documents\curso24_25\Investigacion\UB\GRAF\RFcCentinel\matlab\organized_data_with_baseline.csv", opts);
organizeddatawithbaseline = readtable("C:\Users\javit\Documents\curso24_25\Investigacion\UB\GRAF\RFcCentinel\matlab\organized_data_with_baseline.csv", opts);
% Convert to output type
dataBase = table2array(organizeddatawithbaseline);

% Clear temporary variables
clear organizeddatawithbaseline
clear opts

%% Read the baseline aligned by cow
opts = delimitedTextImportOptions("NumVariables", 201);

% Specify range and delimiter
opts.DataLines = [2, Inf];
opts.Delimiter = ",";

% Specify column names and types
opts.VariableNames = ["Freq_1", "Freq_2", "Freq_3", "Freq_4", "Freq_5", "Freq_6", "Freq_7", "Freq_8", "Freq_9", "Freq_10", "Freq_11", "Freq_12", "Freq_13", "Freq_14", "Freq_15", "Freq_16", "Freq_17", "Freq_18", "Freq_19", "Freq_20", "Freq_21", "Freq_22", "Freq_23", "Freq_24", "Freq_25", "Freq_26", "Freq_27", "Freq_28", "Freq_29", "Freq_30", "Freq_31", "Freq_32", "Freq_33", "Freq_34", "Freq_35", "Freq_36", "Freq_37", "Freq_38", "Freq_39", "Freq_40", "Freq_41", "Freq_42", "Freq_43", "Freq_44", "Freq_45", "Freq_46", "Freq_47", "Freq_48", "Freq_49", "Freq_50", "Freq_51", "Freq_52", "Freq_53", "Freq_54", "Freq_55", "Freq_56", "Freq_57", "Freq_58", "Freq_59", "Freq_60", "Freq_61", "Freq_62", "Freq_63", "Freq_64", "Freq_65", "Freq_66", "Freq_67", "Freq_68", "Freq_69", "Freq_70", "Freq_71", "Freq_72", "Freq_73", "Freq_74", "Freq_75", "Freq_76", "Freq_77", "Freq_78", "Freq_79", "Freq_80", "Freq_81", "Freq_82", "Freq_83", "Freq_84", "Freq_85", "Freq_86", "Freq_87", "Freq_88", "Freq_89", "Freq_90", "Freq_91", "Freq_92", "Freq_93", "Freq_94", "Freq_95", "Freq_96", "Freq_97", "Freq_98", "Freq_99", "Freq_100", "Freq_101", "Freq_102", "Freq_103", "Freq_104", "Freq_105", "Freq_106", "Freq_107", "Freq_108", "Freq_109", "Freq_110", "Freq_111", "Freq_112", "Freq_113", "Freq_114", "Freq_115", "Freq_116", "Freq_117", "Freq_118", "Freq_119", "Freq_120", "Freq_121", "Freq_122", "Freq_123", "Freq_124", "Freq_125", "Freq_126", "Freq_127", "Freq_128", "Freq_129", "Freq_130", "Freq_131", "Freq_132", "Freq_133", "Freq_134", "Freq_135", "Freq_136", "Freq_137", "Freq_138", "Freq_139", "Freq_140", "Freq_141", "Freq_142", "Freq_143", "Freq_144", "Freq_145", "Freq_146", "Freq_147", "Freq_148", "Freq_149", "Freq_150", "Freq_151", "Freq_152", "Freq_153", "Freq_154", "Freq_155", "Freq_156", "Freq_157", "Freq_158", "Freq_159", "Freq_160", "Freq_161", "Freq_162", "Freq_163", "Freq_164", "Freq_165", "Freq_166", "Freq_167", "Freq_168", "Freq_169", "Freq_170", "Freq_171", "Freq_172", "Freq_173", "Freq_174", "Freq_175", "Freq_176", "Freq_177", "Freq_178", "Freq_179", "Freq_180", "Freq_181", "Freq_182", "Freq_183", "Freq_184", "Freq_185", "Freq_186", "Freq_187", "Freq_188", "Freq_189", "Freq_190", "Freq_191", "Freq_192", "Freq_193", "Freq_194", "Freq_195", "Freq_196", "Freq_197", "Freq_198", "Freq_199", "Freq_200", "Freq_201"];
opts.VariableTypes = ["double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"];

% Specify file level properties
opts.ExtraColumnsRule = "ignore";
opts.EmptyLineRule = "read";

% Import the data
%organizeddatawithbaseline = readtable("C:\Users\jalon\Documents\curso24_25\Investigacion\UB\GRAF\RFcCentinel\matlab\organized_data_with_baseline.csv", opts);
baselineTable = readtable("C:\Users\javit\Documents\curso24_25\Investigacion\UB\GRAF\RFcCentinel\python\dataBase_WaterInVial_1p2mL_1p6to3GHz\20241202\cowSpectrum_baseline.csv", opts);
% Convert to output type
baseline = table2array(baselineTable);

%% Import the randomList
opts = delimitedTextImportOptions("NumVariables", 2);
% Specify range and delimiter
opts.DataLines = [1, Inf];
opts.Delimiter = " ";
% Specify column names and types
opts.VariableNames = ["VarName1", "Var2"];
opts.SelectedVariableNames = "VarName1";
opts.VariableTypes = ["double", "char"];
% Specify file level properties
opts.ExtraColumnsRule = "ignore";
opts.EmptyLineRule = "read";
opts.ConsecutiveDelimitersRule = "join";
opts.LeadingDelimitersRule = "ignore";
% Specify variable properties
opts = setvaropts(opts, "Var2", "WhitespaceRule", "preserve");
opts = setvaropts(opts, "Var2", "EmptyFieldRule", "auto");
opts = setvaropts(opts, "VarName1", "TrimNonNumeric", true);
opts = setvaropts(opts, "VarName1", "ThousandsSeparator", ",");
% Import the data
%randomList = readtable("C:\Users\jalon\Documents\curso24_25\Investigacion\UB\GRAF\RFcCentinel\python\dataBase_EthH2O_1p2mL_1p6to3GHz_random\randomList.txt", opts);
randomList = readtable("C:\Users\javit\Documents\curso24_25\Investigacion\UB\GRAF\RFcCentinel\python\dataBase_EthH2O_1p2mL_1p6to3GHz_random\randomList.txt", opts);
% Convert to output type
measList = table2array(randomList);
% Clear temporary variables
clear randomList
clear opts

%% Getting data in different variables
%data
sortData = sortrows(dataBase,202);          %Ordered by label database
data_woBSL = sortData(6:end,:);         
rowsToRemove = [21,57,66,67,75,86,108,146,155,165,168,175,178,185,188,195,198,204,...
    256,258,266,276,301,302,312,405,506,607,708,709];
rowsToKeep = setdiff(1:size(data_woBSL, 1), rowsToRemove);
data = data_woBSL(rowsToKeep, 1:201);               %measured data
y = data_woBSL(rowsToKeep,202);                    %labels
freq = linspace(1.6,3,201);             %Frequency Axis
freqAxis = freq(1:201);
%% Identifying labels and generating axes for processing
% Getting the numbers of the labels
uniqueNumbers = unique(y);
numUnique = numel(uniqueNumbers);
% Counting the number of samples of each label
counts = nonzeros(histcounts(y.', 0:0.1:uniqueNumbers(end)));
%uniqueNumbers = uniqueNumbers(end:-1:1);
uniqueNumbers =uniqueNumbers(1:end);
% Getting the minimum of samples to be consider of each label.
% Not all the labels were sampled the same amount of times.
minCount = min(counts);

%% Reducing the number of samples for each label to get the same for all
Xp = data;
yp = y;

%% Plotting the 20.*log10 (|s21|) raw data
if plt==1
    colors = jet(length(uniqueNumbers));
    %colors = colors(end:-1:1,:);
    legend_handles = gobjects(length(uniqueNumbers), 1);
    hS21 = figure;
    hold on;
    for i = 1:length(uniqueNumbers)
        label = uniqueNumbers(i);
        rows = Xp(yp == label, :);

        for j = 1:size(rows, 1)
            h = plot(freqAxis,rows(j, :), 'Color', colors(i, :));        
            if j == 1
                legend_handles(i) = h;
            end
        end
    end
    hold off;
    xlabel("Freq (GHz)");
    ylabel("20log_{10}|S_{21}|");
    legend(legend_handles, arrayfun(@num2str, uniqueNumbers, 'UniformOutput', false), 'Location', 'best');
end

%% Asymetric Least Squares for baseline removal
z = zeros(size(Xp));
for i = 1:size(Xp,1)
    z(i,:)=asymmetric_least_squares(-Xp(i,:),1e6,0.001,10);
end
X_ALS = -(-Xp - z);

if plt==1
    colors = jet(length(uniqueNumbers));
    legend_handles = gobjects(length(uniqueNumbers), 1);
    hS21_als = figure;
    hold on;
    for i = 1:length(uniqueNumbers)
        label = uniqueNumbers(i);
        rows = X_ALS(yp == label, :);

        for j = 1:size(rows, 1)
            h = plot(freqAxis,rows(j, :), 'Color', colors(i, :));        
            if j == 1
                legend_handles(i) = h;
            end
        end
    end
    hold off;
    xlabel("Freq (GHz)");
    ylabel("20log_{10}|S_{21}|");
    legend(legend_handles, arrayfun(@num2str, uniqueNumbers, 'UniformOutput', false), 'Location', 'best');
end

%% Aligment of each concentration within itself
X_wrp = zeros(size(Xp)); 
for i = 1:length(uniqueNumbers)
    %concentration selection
    disp("Alignning concentration: "+num2str(uniqueNumbers(i)))
    label = uniqueNumbers(i);
    rows = X_ALS(yp == label, :);
    X = -rows;
    %optim_cow for optimal parameters for cow alignment
    optim_space = [5 30 2 20]; %segment lenght limits and slack limits
    options = [0 3 50 .7];
    ref = ref_select(X,[],[1 5]);
    [optim_pars,OS,diagnos] = optim_cow(X,optim_space,options,ref);
    disp("COW optimization diagnosis for concentration: "+num2str(uniqueNumbers(i)))
    diagnos

    %cow with the parameters optimized
    [Warping,XWarped,Diagnos] = cow(ref,X,optim_pars(1),optim_pars(2));
    X_wrp(yp == label,:) = -XWarped;
    disp("Alignned concentration: "+num2str(uniqueNumbers(i)))
end

if plt==1
    colors = jet(length(uniqueNumbers));
    legend_handles = gobjects(length(uniqueNumbers), 1);
    hS21_warped = figure;
    hold on;
    for i = 1:length(uniqueNumbers)
        label = uniqueNumbers(i);
        rows = X_wrp(yp == label, :);
        for j = 1:size(rows, 1)
            h = plot(freqAxis,rows(j, :), 'Color', colors(i, :));        
            if j == 1
                legend_handles(i) = h;
            end
        end
    end
    hold off;
    xlabel("Freq (GHz)");
    ylabel("20log_{10}|S_{21}|");
    legend(legend_handles, arrayfun(@num2str, uniqueNumbers, 'UniformOutput', false), 'Location', 'best');
end

% %% Baseline corrections 
% X_bc = X_ALS - repmat(baseline,size(X_ALS,1),1);
% %X_bc = X_wrp;
% if plt==1
%     colors = jet(length(uniqueNumbers));
%     %colors = colors(end:-1:1,:);
%     legend_handles = gobjects(length(uniqueNumbers), 1);
%     hS21_bc = figure;
%     hold on;
%     for i = 1:length(uniqueNumbers)
%         label = uniqueNumbers(i);
%         rows = X_bc(yp == label, :);
% 
%         for j = 1:size(rows, 1)
%             %[val, idx]=min(20.*log10(abs(rows(j,:)./rowsb)));
%             h = plot(freqAxis,rows(j, :), 'Color', colors(i, :));        
%             %text(freqAxis(idx), val, num2str(j), ...
%             %    'HorizontalAlignment', 'left', ...
%             %    'VerticalAlignment', 'middle');
%             if j == 1
%                 legend_handles(i) = h;
%             end
%         end
%     end
%     hold off;
%     xlabel("Freq (GHz)");
%     ylabel("20log_{10}|S_{21}|");
%     legend(legend_handles, arrayfun(@num2str, uniqueNumbers, 'UniformOutput', false), 'Location', 'best');
% end
%
%% Feature Extraction. Frequency distance and Qs
maxPeaks = 0;
maxDists = 0;
tolerance = 0.21; 

for i = 1:size(X_wrp,1)
    %Distances calculations
    spec = X_wrp(i,:);
    [pks, locs] = findpeaks(-spec,'MinPeakProminence',0.5);
    freqPeaks = freqAxis(locs);
    dist = diff(freqPeaks);
    if i == 1
        locs_ref = locs;
        fref = freqAxis(locs_ref);
    end
    %Qs calculations
    Qs = zeros(size(freqPeaks));
    for j = 1: length(freqPeaks)
        [minDist, idx] = min(abs(freqPeaks-fref(j)));  
        if minDist <= tolerance
            f0 = freqPeaks(j);
            peakHeight = -pks(j);
            halfPower = peakHeight+2;
        
            leftIdx = locs(j);
            while leftIdx > 1 && spec(leftIdx) < halfPower
                leftIdx = leftIdx -1;
            end
        
            rightIdx = locs(j);
            while rightIdx > 1 && spec(rightIdx) < halfPower && rightIdx <= size(spec,2)-1
                rightIdx = rightIdx+1;
            end

            if leftIdx == 1 || rightIdx == length(spec)
                deltaF = 0;
            else
                deltaF = freqAxis(rightIdx)-freqAxis(leftIdx);
            end
            Qs(j) = f0/deltaF;
        else
            Qs(j) = 0;
        end
    end

    freqCell{i} = freqPeaks;
    distCells{i} = dist;
    QsCell{i} = Qs;

    maxPeaks = max(maxPeaks,length(Qs));
    maxDists = max(maxDists,length(dist));
end

finalDists = zeros(size(X_wrp,1),maxDists);
finalQs = zeros(size(X_wrp,1),maxPeaks);
finalFreqs = zeros(size(X_wrp,1),maxPeaks);

for i = 1:size(X_wrp,1)
    nD = length(distsCell{i});
    nQ = length(QsCell{i});
    finalFreqs(i,1:nQ) = freqCell{i};
    finalDists(i,1:nD) = distsCell{i};
    finalQs(i,1:nQ) = QsCell{i};
end
finalQs(isinf(finalQs)) = 0;
X_bc = cat(2,finalFreqs,finalDists,finalQs);

%% Autoscaling only magnitude
X_mean = mean(X_bc);
X_std = std(X_bc);
X_autoS = (X_bc-X_mean)./X_std;
X_autoS = X_bc;
%Plotting the autoscales
if plt==1
    colors = jet(length(uniqueNumbers));
    %colors = colors(end:-1:1,:);
    legend_handles = gobjects(length(uniqueNumbers), 1);
    figure;
    hold on;
    for i = 1:length(uniqueNumbers)
        label = uniqueNumbers(i);
        rows = X_autoS(yp == label, :);
        rowsb = baseline(1,:);
        for j = 1:size(rows, 1)
            %[val, idx]=min(20.*log10(abs(rows(j,:)./rowsb)));
            h = plot(rows(j, :), 'Color', colors(i, :));        
            %text(freqAxis(idx), val, num2str(j), ...
            %    'HorizontalAlignment', 'left', ...
            %    'VerticalAlignment', 'middle');
            if j == 1
                legend_handles(i) = h;
            end
        end
    end
    hold off;
    xlabel("Freq (GHz)");
    ylabel("Autoscaled Data");
    legend(legend_handles, arrayfun(@num2str, uniqueNumbers, 'UniformOutput', false), 'Location', 'best');
end

%% Extracting the most different spectra from the sintetic spectrum
X_aux1 = X_autoS;
X_aux2 = X_bc;
y_aux = yp;

%% Partitioning the dataset for training, test and so on
%Extracting data for external validation
[rowsEV, ~]=find(y_aux==[80,60,40]);
rowsLeft = setdiff(1:size(X_aux1, 1), rowsEV);
X_Test = X_aux1(rowsEV,:);
y_Test = y_aux(rowsEV);
X_Train = X_aux1(rowsLeft,:);
y_Train = yp(rowsLeft);
X_mean = mean(X_Train);
X_std = std(X_Train);
%X_Train = (X_Train-X_mean)./X_std;
X_Train = (X_Train-X_mean);
%Dividing training dataSet
tUniqueNumbers = uniqueNumbers(~ismember(uniqueNumbers,[80,60,40]));
groups = repelem(1:length(tUniqueNumbers), minCount)';  
% Split Data into training and internal validation
cv = cvpartition(groups, 'Holdout', 0.2,'Stratify',false);
X_train = X_Train(training(cv), :);
Y_train = y_Train(training(cv), :);
groups_train = groups(training(cv));
X_test = X_Train(test(cv), :);
Y_test = y_Train(test(cv), :);


%% LOGO Cross-Validation
% preparing the control variables
uniqueGroups = unique(groups_train);
maxComponents = 9; 
mseCV = zeros(maxComponents, 1);

for nComp = 1:maxComponents
    mseGroup = zeros(length(uniqueGroups), 1);
    Y_pred_tot = [];
    for i = 1:length(uniqueGroups)
        
        testIdx = (groups_train == uniqueGroups(i));
        trainIdx = ~testIdx;
        X_t2 = X_train(trainIdx, :);
        Y_t2 = Y_train(trainIdx, :);
        row_indices = randperm(size(X_t2, 1));
        X_train_logo = X_t2(row_indices,:);
        Y_train_logo = Y_t2(row_indices);
        X_test_logo = X_train(testIdx, :);
        Y_test_logo = Y_train(testIdx, :);
        
        [XL, YL, XS, YS, beta,PCTVAR,MSE,PLSstats] = plsregress(X_train_logo, Y_train_logo, nComp);

        % Calculate normalized PLS weights
        W0 = bsxfun(@rdivide,PLSstats.W,sqrt(sum(PLSstats.W.^2,1)));
        % Calculate the product of summed squares of XS and YL
        sumSq = sum(XS.^2,1).*sum(YL.^2,1);
        % Calculate VIP scores for NCOMP components
        vipScores(i,:) = sqrt(size(XL,1) * sum(bsxfun(@times,sumSq,W0.^2),2) ./ sum(sumSq,2));        

        % Prediction and Error Calculation
        Y_pred_logo = [ones(size(X_test_logo, 1), 1), X_test_logo] * beta;
        mseGroup(i) = sqrt(mean((Y_test_logo - Y_pred_logo).^2));
        Y_pred_tot = cat(1,Y_pred_tot,Y_pred_logo);

    end
    
    % Average MSE Across Groups
    mseCV(nComp) = mean(mseGroup);
    % Store Average VIP Scores Across Folds
    vipScoresMean(nComp,:) = mean(vipScores, 1);
    % rmse total
    mseLVs(nComp) = sqrt(mean((Y_train - Y_pred_tot).^2));
end


if plt==1
    figure;
    plot(1:maxComponents, sqrt(mseLVs), '-o');
    xlabel('Number of Components');
    ylabel('Cross-Validated RMSE');
    title('LOGO Cross-Validation');
    grid on;
end

%% Plot VIP scores for understanding
th = 1;
optimalComp = find(mseLVs == min(mseLVs), 1); % Find the optimal number of components
vipOptimal = mean(vipScores,1); % VIP scores for optimal components
[~,idxVipFeat]=find(vipOptimal>=th);
if plt==1
    figure;
    % fAxis = freqAxis;
    % stem(fAxis,vipOptimal);
    stem(vipOptimal);
    clusters = clusterVips(idxVipFeat.');
    pink_color = [1.0, 0.75, 0.8];
    % for nCls = 1:length(clusters)
    %     cluster = clusters{:,nCls};
    %     if length(cluster)>1
    %         % Define the rectangle coordinates
    %         rectangle('Position',[fAxis(min(cluster)) 0 fAxis(max(cluster))-fAxis(min(cluster)) 2],'EdgeColor','r','FaceColor',[1, 0, 0, 0.5])
    %     end
    % end
    % yline(th,"LineWidth",2)
    % xlabel('\nu (GHz)');
    % ylabel('Average VIP Score');
    % title('Averaged VIP Scores for ');
    % xlim([min(freqAxis), max(freqAxis)])
    % ylim([0 2]);
    % grid on;
    % figure(hS21_als);
    % for nCls = 1:length(clusters)
    %     cluster = clusters{:,nCls};
    %     if length(cluster)>1
    %         % Define the rectangle coordinates
    %         rectangle('Position',[fAxis(min(cluster)) -10 fAxis(max(cluster))-fAxis(min(cluster)) 10],'EdgeColor','r','FaceColor',[1, 0, 0, 0.5])
    %     end
    % end
     %ylim([-10 3]);
end

%% Peformance Analysis
%Performance during cross-validatios
disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%');
disp('%%%% PERFORMANCE DURING LOGO CROSS VALIDATION %%%%%%%%%%%%%%%%%%%');
[~, optimalComponents] = min(mseLVs);
disp(['Optimal Number of Components: ', num2str(optimalComponents)]);
row_indices = randperm(size(X_train, 1));
[XLF, YLF, XSF, YSF, betaFinal, PLSstatsF] = plsregress(X_Train, y_Train, optimalComponents);
Y_pred_CV = [ones(size(X_test, 1), 1), X_test] * betaFinal;
mseTest = sqrt(mean((Y_test - Y_pred_CV).^2));
RSS = sum((Y_test - Y_pred_CV).^2);
TSS = sum((Y_test - mean(Y_test)).^2);
r2 = 1 - (RSS / TSS);
disp(['Cross-Validation RMSECV: ', num2str(mseTest)]);
disp(['Cross-Validation R^{2}: ', num2str(r2)]);
%Bland-Altman+model
minVal = min([Y_test; Y_pred_CV]);
maxVal = max([Y_test; Y_pred_CV]);
% Calculate Bias and Limits of Agreement
bias = mean(Y_pred_CV - Y_test); % Mean difference
LoA = 1.96 * std(Y_pred_CV - Y_test); % Limits of agreement (±1.96 * SD)
% Add Labels for LoA Lines
upperLoA = bias + LoA; % Upper LoA value
lowerLoA = bias - LoA; % Lower LoA value
disp(['Cross-Validation Upper LoA: ', num2str(upperLoA), ' (+1.96SD)']);
disp(['Cross-Validation Lower LoA: ', num2str(lowerLoA), ' (-1.96SD)']);

%%
%Bland-Altman plot
if plt == 1
    figure;
    scatter(Y_test, Y_pred_CV, 'b', 'filled'); % Scatter plot of predicted vs actual
    hold on;
    plot([minVal, maxVal], [minVal, maxVal], 'k', 'LineWidth', 1.5); % Perfect agreement line

    % Add Bland-Altman Lines Parallel to the Diagonal
    biasLine = plot([minVal, maxVal], [minVal + bias, maxVal + bias], 'r', 'LineWidth', 1.5); % Bias line
    upperLoALine = plot([minVal, maxVal], [minVal + bias + LoA, maxVal + bias + LoA], 'k-.', 'LineWidth', 1.5); % Upper LoA
    lowerLoALine = plot([minVal, maxVal], [minVal + bias - LoA, maxVal + bias - LoA], 'k-.', 'LineWidth', 1.5); % Lower LoA

    % Calculate slopes of LoA lines
    dx = maxVal - minVal; % Horizontal difference
    dy_upper = (maxVal + upperLoA) - (minVal + upperLoA); % Vertical difference for upper LoA
    dy_lower = (maxVal + lowerLoA) - (minVal + lowerLoA); % Vertical difference for lower LoA
    % Angle for text rotation
    angle_upper = atand(dy_upper / dx)-11; % Angle of upper LoA in degrees
    angle_lower = atand(dy_lower / dx)-11; % Angle of lower LoA in degrees

    % Place text parallel to Upper LoA Line
    textX_upper = minVal + 0.65 * dx; % Position slightly along the line
    textY_upper = (minVal + upperLoA) + 0.73 * dy_upper; % Position slightly along the line
    text(textX_upper, textY_upper, sprintf('LoA = %.2f (+1.96SD)', upperLoA), ...
        'Color', 'k', 'FontSize', 10, 'Rotation', angle_upper, 'HorizontalAlignment', 'center');

    % Place text parallel to Lower LoA Line
    textX_lower = minVal + 0.75 * dx; % Position slightly along the line
    textY_lower = (minVal + lowerLoA) + 0.67 * dy_lower; % Position slightly along the line
    text(textX_lower, textY_lower, sprintf('LoA = %.2f (-1.96SD)', lowerLoA), ...
        'Color', 'k', 'FontSize', 10, 'Rotation', angle_lower, 'HorizontalAlignment', 'center');

    % Customize Plot
    xlim([0 100]);
    ylim([0 100]);
    xlabel('Actual Eth. Concentration (CV)');
    ylabel('Predicted Eth. Concentration');
    title('Predicted vs. Actual');
    legend('Predicted vs Actual', 'Perfect Agreement', 'Bias', 'Limits of Agreement', 'Location', 'Best');
    grid on;
    hold off;
end


%% Performance in external validation
disp('%%%% PERFORMANCE DURING EXTERNAL VALIDATION %%%%%%%%%%%%%%%%%%%%%%');
%Calculation of the prediction
%X_Test = (X_Test-X_mean)./X_std;
X_Test = (X_Test-X_mean);
Y_pred_test = [ones(size(X_Test, 1), 1), X_Test] * betaFinal;
mseTest = sqrt(mean((y_Test - Y_pred_test).^2));
RSSinterp = sum((y_Test - Y_pred_test).^2);
TSSinterp = sum((y_Test - mean(y_Test)).^2);
r2interp = 1 - (RSSinterp / TSSinterp);
disp(['Test RMSEP: ', num2str(mseTest)]);
disp(['Test R^{2}: ', num2str(r2)]);
%Bland-Altman+model
%minVal = min([y_Test; Y_pred_test]);
%maxVal = max([y_Test; Y_pred_test]);
% Calculate Bias and Limits of Agreement
bias = mean(Y_pred_test - y_Test); % Mean difference
LoA = 1.96 * std(Y_pred_test - y_Test); % Limits of agreement (±1.96 * SD)
% Add Labels for LoA Lines
upperLoA = bias + LoA; % Upper LoA value
lowerLoA = bias - LoA; % Lower LoA value
disp(['Test Upper LoA: ', num2str(upperLoA), ' (+1.96SD)']);
disp(['Test Lower LoA: ', num2str(lowerLoA), ' (-1.96SD)']);
disp('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%');

%%
%Bland-Altman plot
if plt == 1
    figure;

    scatter(y_Test, Y_pred_test, 'b', 'filled'); % Scatter plot of predicted vs actual
    hold on;
    plot([minVal, maxVal], [minVal, maxVal], 'k', 'LineWidth', 1.5); % Perfect agreement line

    % Add Bland-Altman Lines Parallel to the Diagonal
    biasLine = plot([minVal, maxVal], [minVal + bias, maxVal + bias], 'r', 'LineWidth', 1.5); % Bias line
    upperLoALine = plot([minVal, maxVal], [minVal + bias + LoA, maxVal + bias + LoA], 'k-.', 'LineWidth', 1.5); % Upper LoA
    lowerLoALine = plot([minVal, maxVal], [minVal + bias - LoA, maxVal + bias - LoA], 'k-.', 'LineWidth', 1.5); % Lower LoA

    % Calculate slopes of LoA lines
    dx = maxVal - minVal; % Horizontal difference
    dy_upper = (maxVal + upperLoA) - (minVal + upperLoA); % Vertical difference for upper LoA
    dy_lower = (maxVal + lowerLoA) - (minVal + lowerLoA); % Vertical difference for lower LoA
    % Angle for text rotation
    angle_upper = atand(dy_upper / dx)-16; % Angle of upper LoA in degrees
    angle_lower = atand(dy_lower / dx)-15; % Angle of lower LoA in degrees

    % Place text parallel to Upper LoA Line
    textX_upper = minVal + 0.65 * dx; % Position slightly along the line
    textY_upper = (minVal + upperLoA) + 0.73 * dy_upper; % Position slightly along the line
    text(textX_upper, textY_upper, sprintf('LoA = %.2f (+1.96SD)', upperLoA), ...
        'Color', 'k', 'FontSize', 10, 'Rotation', angle_upper, 'HorizontalAlignment', 'center');

    % Place text parallel to Lower LoA Line
    textX_lower = minVal + 0.75 * dx; % Position slightly along the line
    textY_lower = (minVal + lowerLoA) + 0.67 * dy_lower; % Position slightly along the line
    text(textX_lower, textY_lower, sprintf('LoA = %.2f (-1.96SD)', lowerLoA), ...
        'Color', 'k', 'FontSize', 10, 'Rotation', angle_lower, 'HorizontalAlignment', 'center');

    % Customize Plot
        xlim([0 100]);
    ylim([0 100]);
    xlabel('Actual Eth. Concentration (Test)');
    ylabel('Predicted Eth. Concentration');
    title('Predicted vs. Actual in External Validation');
    legend('Predicted vs Actual', 'Perfect Agreement', 'Bias', 'Limits of Agreement', 'Location', 'Best');
    grid on;
    hold off;
end

